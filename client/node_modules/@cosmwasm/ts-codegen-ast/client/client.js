"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypeInterface = exports.createTypeOrInterface = exports.createQueryInterface = exports.createPropertyFunctionWithObjectParamsForExec = exports.createPropertyFunctionWithObjectParams = exports.createExecuteInterface = exports.createExecuteClass = exports.createWasmExecMethod = exports.getWasmMethodArgs = exports.createQueryClass = exports.createWasmQueryMethod = exports.CONSTANT_EXEC_PARAMS = void 0;
const t = __importStar(require("@babel/types"));
const case_1 = require("case");
const utils_1 = require("../utils");
const babel_1 = require("../utils/babel");
const types_1 = require("../utils/types");
exports.CONSTANT_EXEC_PARAMS = [
    t.assignmentPattern((0, babel_1.identifier)('fee', t.tsTypeAnnotation(t.tsUnionType([
        t.tSNumberKeyword(),
        t.tsTypeReference(t.identifier('StdFee')),
        t.tsLiteralType(t.stringLiteral('auto'))
    ])), false), t.stringLiteral('auto')),
    (0, babel_1.identifier)('memo', t.tsTypeAnnotation(t.tsStringKeyword()), true),
    utils_1.OPTIONAL_FUNDS_PARAM
];
const createWasmQueryMethod = (context, jsonschema) => {
    const underscoreName = Object.keys(jsonschema.properties)[0];
    const methodName = (0, case_1.camel)(underscoreName);
    const responseType = (0, types_1.getResponseType)(context, underscoreName);
    const param = (0, types_1.createTypedObjectParams)(context, jsonschema.properties[underscoreName]);
    const args = (0, exports.getWasmMethodArgs)(context, jsonschema.properties[underscoreName]);
    const msgAction = t.identifier(underscoreName);
    // If the param is an identifier, we can just use it as is
    const msgActionValue = param?.type === 'Identifier'
        ? t.identifier(param.name)
        : t.objectExpression(args);
    return t.classProperty(t.identifier(methodName), (0, utils_1.arrowFunctionExpression)(param ? [param] : [], t.blockStatement([
        t.returnStatement(t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('queryContractSmart')), [
            t.memberExpression(t.thisExpression(), t.identifier('contractAddress')),
            t.objectExpression([t.objectProperty(msgAction, msgActionValue)])
        ]))
    ]), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([
        t.tSTypeReference(t.identifier(responseType))
    ]))), true));
};
exports.createWasmQueryMethod = createWasmQueryMethod;
const createQueryClass = (context, className, implementsClassName, queryMsg) => {
    context.addUtil('CosmWasmClient');
    const propertyNames = (0, utils_1.getMessageProperties)(queryMsg)
        .map((method) => Object.keys(method.properties)?.[0])
        .filter(Boolean);
    const bindings = propertyNames.map(case_1.camel).map(utils_1.bindMethod);
    const methods = (0, utils_1.getMessageProperties)(queryMsg).map((schema) => {
        return (0, exports.createWasmQueryMethod)(context, schema);
    });
    return t.exportNamedDeclaration((0, utils_1.classDeclaration)(className, [
        // client
        (0, utils_1.classProperty)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('CosmWasmClient')))),
        // contractAddress
        (0, utils_1.classProperty)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword())),
        // constructor
        t.classMethod('constructor', t.identifier('constructor'), [
            (0, utils_1.typedIdentifier)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('CosmWasmClient')))),
            (0, utils_1.typedIdentifier)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword()))
        ], t.blockStatement([
            // client/contract set
            t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('client'))),
            t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('contractAddress')), t.identifier('contractAddress'))),
            ...bindings
        ])),
        ...methods
    ], [t.tSExpressionWithTypeArguments(t.identifier(implementsClassName))]));
};
exports.createQueryClass = createQueryClass;
const getWasmMethodArgs = (context, jsonschema) => {
    let keys = Object.keys(jsonschema.properties ?? {});
    // only 1 degree $ref-lookup
    if (!keys.length && jsonschema.$ref) {
        const obj = context.refLookup(jsonschema.$ref);
        // properties
        if (obj) {
            keys = Object.keys(obj.properties ?? {});
        }
        // tuple struct or otherwise, use the name of the reference
        if (!keys.length && obj?.oneOf) {
            // TODO????? ADAIR
        }
    }
    const args = keys.map((prop) => {
        return t.objectProperty(t.identifier(prop), t.identifier((0, case_1.camel)(prop)), false, prop === (0, case_1.camel)(prop));
    });
    return args;
};
exports.getWasmMethodArgs = getWasmMethodArgs;
const createWasmExecMethod = (context, jsonschema) => {
    context.addUtil('ExecuteResult');
    context.addUtil('StdFee');
    context.addUtil('Coin');
    const underscoreName = Object.keys(jsonschema.properties)[0];
    const methodName = (0, case_1.camel)(underscoreName);
    const param = (0, types_1.createTypedObjectParams)(context, jsonschema.properties[underscoreName]);
    const args = (0, exports.getWasmMethodArgs)(context, jsonschema.properties[underscoreName]);
    const msgAction = t.identifier(underscoreName);
    // If the param is an identifier, we can just use it as is
    const msgActionValue = param?.type === 'Identifier'
        ? t.identifier(param.name)
        : t.objectExpression(args);
    return t.classProperty(t.identifier(methodName), (0, utils_1.arrowFunctionExpression)(param
        ? [
            // props
            param,
            ...exports.CONSTANT_EXEC_PARAMS
        ]
        : exports.CONSTANT_EXEC_PARAMS, t.blockStatement([
        t.returnStatement(t.awaitExpression(t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('execute')), [
            t.memberExpression(t.thisExpression(), t.identifier('sender')),
            t.memberExpression(t.thisExpression(), t.identifier('contractAddress')),
            t.objectExpression([
                t.objectProperty(msgAction, msgActionValue)
            ]),
            t.identifier('fee'),
            t.identifier('memo'),
            t.identifier('_funds')
        ])))
    ]), 
    // return type
    t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([
        t.tSTypeReference(t.identifier('ExecuteResult'))
    ]))), true));
};
exports.createWasmExecMethod = createWasmExecMethod;
const createExecuteClass = (context, className, implementsClassName, extendsClassName, execMsg) => {
    context.addUtil('SigningCosmWasmClient');
    const propertyNames = (0, utils_1.getMessageProperties)(execMsg)
        .map((method) => Object.keys(method.properties)?.[0])
        .filter(Boolean);
    const bindings = propertyNames.map(case_1.camel).map(utils_1.bindMethod);
    const methods = (0, utils_1.getMessageProperties)(execMsg).map((schema) => {
        return (0, exports.createWasmExecMethod)(context, schema);
    });
    const blockStmt = [];
    if (extendsClassName) {
        blockStmt.push(
        // super()
        t.expressionStatement(t.callExpression(t.super(), [
            t.identifier('client'),
            t.identifier('contractAddress')
        ])));
    }
    blockStmt.push(...[
        // client/contract set
        t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('client'))),
        t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('sender')), t.identifier('sender'))),
        t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('contractAddress')), t.identifier('contractAddress'))),
        ...bindings
    ]);
    const noImplicitOverride = context.options.client.noImplicitOverride &&
        extendsClassName &&
        context.options.client.execExtendsQuery;
    return t.exportNamedDeclaration((0, utils_1.classDeclaration)(className, [
        // client
        (0, utils_1.classProperty)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('SigningCosmWasmClient'))), false, false, noImplicitOverride),
        // sender
        (0, utils_1.classProperty)('sender', t.tsTypeAnnotation(t.tsStringKeyword())),
        // contractAddress
        (0, utils_1.classProperty)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword()), false, false, noImplicitOverride),
        // constructor
        t.classMethod('constructor', t.identifier('constructor'), [
            (0, utils_1.typedIdentifier)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('SigningCosmWasmClient')))),
            (0, utils_1.typedIdentifier)('sender', t.tsTypeAnnotation(t.tsStringKeyword())),
            (0, utils_1.typedIdentifier)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword()))
        ], t.blockStatement(blockStmt)),
        ...methods
    ], [t.tSExpressionWithTypeArguments(t.identifier(implementsClassName))], extendsClassName ? t.identifier(extendsClassName) : null));
};
exports.createExecuteClass = createExecuteClass;
const createExecuteInterface = (context, className, extendsClassName, execMsg) => {
    const methods = (0, utils_1.getMessageProperties)(execMsg).map((jsonschema) => {
        const underscoreName = Object.keys(jsonschema.properties)[0];
        const methodName = (0, case_1.camel)(underscoreName);
        return (0, exports.createPropertyFunctionWithObjectParamsForExec)(context, methodName, 'ExecuteResult', jsonschema.properties[underscoreName]);
    });
    const extendsAst = extendsClassName
        ? [t.tSExpressionWithTypeArguments(t.identifier(extendsClassName))]
        : [];
    return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(className), null, extendsAst, t.tSInterfaceBody([
        // contract address
        t.tSPropertySignature(t.identifier('contractAddress'), t.tsTypeAnnotation(t.tsStringKeyword())),
        // contract address
        t.tSPropertySignature(t.identifier('sender'), t.tsTypeAnnotation(t.tsStringKeyword())),
        ...methods
    ])));
};
exports.createExecuteInterface = createExecuteInterface;
const createPropertyFunctionWithObjectParams = (context, methodName, responseType, jsonschema) => {
    const obj = (0, types_1.createTypedObjectParams)(context, jsonschema);
    const func = {
        type: 'TSFunctionType',
        typeAnnotation: (0, utils_1.promiseTypeAnnotation)(responseType),
        parameters: obj ? [obj] : []
    };
    return t.tSPropertySignature(t.identifier(methodName), t.tsTypeAnnotation(
    // @ts-ignore:next-line
    func));
};
exports.createPropertyFunctionWithObjectParams = createPropertyFunctionWithObjectParams;
const createPropertyFunctionWithObjectParamsForExec = (context, methodName, responseType, jsonschema) => {
    context.addUtil('Coin');
    const obj = (0, types_1.createTypedObjectParams)(context, jsonschema);
    const func = {
        type: 'TSFunctionType',
        typeAnnotation: (0, utils_1.promiseTypeAnnotation)(responseType),
        parameters: obj ? [obj, ...utils_1.FIXED_EXECUTE_PARAMS] : utils_1.FIXED_EXECUTE_PARAMS
    };
    return t.tSPropertySignature(t.identifier(methodName), t.tsTypeAnnotation(
    // @ts-ignore:next-line
    func));
};
exports.createPropertyFunctionWithObjectParamsForExec = createPropertyFunctionWithObjectParamsForExec;
const createQueryInterface = (context, className, queryMsg) => {
    const methods = (0, utils_1.getMessageProperties)(queryMsg).map((jsonschema) => {
        const underscoreName = Object.keys(jsonschema.properties)[0];
        const methodName = (0, case_1.camel)(underscoreName);
        const responseType = (0, types_1.getResponseType)(context, underscoreName);
        return (0, exports.createPropertyFunctionWithObjectParams)(context, methodName, responseType, jsonschema.properties[underscoreName]);
    });
    return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(className), null, [], t.tSInterfaceBody([
        t.tSPropertySignature(t.identifier('contractAddress'), t.tsTypeAnnotation(t.tsStringKeyword())),
        ...methods
    ])));
};
exports.createQueryInterface = createQueryInterface;
const createTypeOrInterface = (context, Type, jsonschema) => {
    // Handle non-object and potentially union or referenced types
    if (jsonschema.type !== 'object') {
        if (!jsonschema.type) {
            if (jsonschema.title) {
                return t.exportNamedDeclaration(t.tsTypeAliasDeclaration(t.identifier(Type), null, t.tsTypeReference(t.identifier(jsonschema.title))));
            }
            else {
                throw new Error('Schema must have a type or title!');
            }
        }
        // Use getTypeOrRef to handle string, array of strings, or $ref
        const typeAnnotation = (0, utils_1.getTypeOrRef)(jsonschema);
        return t.exportNamedDeclaration(t.tsTypeAliasDeclaration(t.identifier(Type), null, typeAnnotation));
    }
    // Handle object type schemas
    const props = Object.keys(jsonschema.properties ?? {}).map((prop) => {
        const { type, optional } = (0, types_1.getPropertyType)(context, jsonschema, prop);
        return (0, babel_1.propertySignature)((0, case_1.camel)(prop), t.tsTypeAnnotation(type), optional);
    });
    return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(Type), null, [], t.tsInterfaceBody([...props])));
};
exports.createTypeOrInterface = createTypeOrInterface;
const createTypeInterface = (context, jsonschema) => {
    const Type = jsonschema.title;
    return (0, exports.createTypeOrInterface)(context, Type, jsonschema);
};
exports.createTypeInterface = createTypeInterface;
